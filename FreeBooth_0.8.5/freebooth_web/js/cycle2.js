/*! * jQuery Cycle2; version: 2.1.6 build: 20141007 * http://jquery.malsup.com/cycle2/ * Copyright (c) 2014 M. Alsup; Dual licensed: MIT/GPL */ /* Cycle2 core engine */ ;(function($) { "use strict"; var version = '2.1.6'; $.fn.cycle = function( options ) { // fix mistakes with the ready state var o; if ( this.length === 0 && !$.isReady ) { o = { s: this.selector, c: this.context }; $.fn.cycle.log('requeuing slideshow (dom not ready)'); $(function() { $( o.s, o.c ).cycle(options); }); return this; } return this.each(function() { var data, opts, shortName, val; var container = $(this); var log = $.fn.cycle.log; if ( container.data('cycle.opts') ) return; // already initialized if ( container.data('cycle-log') === false || ( options && options.log === false ) || ( opts && opts.log === false) ) { log = $.noop; } log('--c2 init--'); data = container.data(); for (var p in data) { // allow props to be accessed sans 'cycle' prefix and log the overrides if (data.hasOwnProperty(p) && /^cycle[A-Z]+/.test(p) ) { val = data[p]; shortName = p.match(/^cycle(.*)/)[1].replace(/^[A-Z]/, lowerCase); log(shortName+':', val, '('+typeof val +')'); data[shortName] = val; } } opts = $.extend( {}, $.fn.cycle.defaults, data, options || {}); opts.timeoutId = 0; opts.paused = opts.paused || false; // #57 opts.container = container; opts._maxZ = opts.maxZ; opts.API = $.extend ( { _container: container }, $.fn.cycle.API ); opts.API.log = log; opts.API.trigger = function( eventName, args ) { opts.container.trigger( eventName, args ); return opts.API; }; container.data( 'cycle.opts', opts ); container.data( 'cycle.API', opts.API ); // opportunity for plugins to modify opts and API opts.API.trigger('cycle-bootstrap', [ opts, opts.API ]); opts.API.addInitialSlides(); opts.API.preInitSlideshow(); if ( opts.slides.length ) opts.API.initSlideshow(); }); }; $.fn.cycle.API = { opts: function() { return this._container.data( 'cycle.opts' ); }, addInitialSlides: function() { var opts = this.opts(); var slides = opts.slides; opts.slideCount = 0; opts.slides = $(); // empty set // add slides that already exist slides = slides.jquery ? slides : opts.container.find( slides ); if ( opts.random ) { slides.sort(function() {return Math.random() - 0.5;}); } opts.API.add( slides ); }, preInitSlideshow: function() { var opts = this.opts(); opts.API.trigger('cycle-pre-initialize', [ opts ]); var tx = $.fn.cycle.transitions[opts.fx]; if (tx && $.isFunction(tx.preInit)) tx.preInit( opts ); opts._preInitialized = true; }, postInitSlideshow: function() { var opts = this.opts(); opts.API.trigger('cycle-post-initialize', [ opts ]); var tx = $.fn.cycle.transitions[opts.fx]; if (tx && $.isFunction(tx.postInit)) tx.postInit( opts ); }, initSlideshow: function() { var opts = this.opts(); var pauseObj = opts.container; var slideOpts; opts.API.calcFirstSlide(); if ( opts.container.css('position') == 'static' ) opts.container.css('position', 'relative'); $(opts.slides[opts.currSlide]).css({ opacity: 1, display: 'block', visibility: 'visible' }); opts.API.stackSlides( opts.slides[opts.currSlide], opts.slides[opts.nextSlide], !opts.reverse ); if ( opts.pauseOnHover ) { // allow pauseOnHover to specify an element if ( opts.pauseOnHover !== true ) pauseObj = $( opts.pauseOnHover ); pauseObj.hover( function(){ opts.API.pause( true ); }, function(){ opts.API.resume( true ); } ); } // stage initial transition if ( opts.timeout ) { slideOpts = opts.API.getSlideOpts( opts.currSlide ); opts.API.queueTransition( slideOpts, slideOpts.timeout + opts.delay ); } opts._initialized = true; opts.API.updateView( true ); opts.API.trigger('cycle-initialized', [ opts ]); opts.API.postInitSlideshow(); }, pause: function( hover ) { var opts = this.opts(), slideOpts = opts.API.getSlideOpts(), alreadyPaused = opts.hoverPaused || opts.paused; if ( hover ) opts.hoverPaused = true; else opts.paused = true; if ( ! alreadyPaused ) { opts.container.addClass('cycle-paused'); opts.API.trigger('cycle-paused', [ opts ]).log('cycle-paused'); if ( slideOpts.timeout ) { clearTimeout( opts.timeoutId ); opts.timeoutId = 0; // determine how much time is left for the current slide opts._remainingTimeout -= ( $.now() - opts._lastQueue ); if ( opts._remainingTimeout < 0 || isNaN(opts._remainingTimeout) ) opts._remainingTimeout = undefined; } } }, resume: function( hover ) { var opts = this.opts(), alreadyResumed = !opts.hoverPaused && !opts.paused, remaining; if ( hover ) opts.hoverPaused = false; else opts.paused = false; if ( ! alreadyResumed ) { opts.container.removeClass('cycle-paused'); // #gh-230; if an animation is in progress then don't queue a new transition; it will // happen naturally if ( opts.slides.filter(':animated').length === 0 ) opts.API.queueTransition( opts.API.getSlideOpts(), opts._remainingTimeout ); opts.API.trigger('cycle-resumed', [ opts, opts._remainingTimeout ] ).log('cycle-resumed'); } }, add: function( slides, prepend ) { var opts = this.opts(); var oldSlideCount = opts.slideCount; var startSlideshow = false; var len; if ( $.type(slides) == 'string') slides = $.trim( slides ); $( slides ).each(function(i) { var slideOpts; var slide = $(this); if ( prepend ) opts.container.prepend( slide ); else opts.container.append( slide ); opts.slideCount++; slideOpts = opts.API.buildSlideOpts( slide ); if ( prepend ) opts.slides = $( slide ).add( opts.slides ); else opts.slides = opts.slides.add( slide ); opts.API.initSlide( slideOpts, slide, --opts._maxZ ); slide.data('cycle.opts', slideOpts); opts.API.trigger('cycle-slide-added', [ opts, slideOpts, slide ]); }); opts.API.updateView( true ); startSlideshow = opts._preInitialized && (oldSlideCount < 2 && opts.slideCount >= 1); if ( startSlideshow ) { if ( !opts._initialized ) opts.API.initSlideshow(); else if ( opts.timeout ) { len = opts.slides.length; opts.nextSlide = opts.reverse ? len - 1 : 1; if ( !opts.timeoutId ) { opts.API.queueTransition( opts ); } } } }, calcFirstSlide: function() { var opts = this.opts(); var firstSlideIndex; firstSlideIndex = parseInt( opts.startingSlide || 0, 10 ); if (firstSlideIndex >= opts.slides.length || firstSlideIndex < 0) firstSlideIndex = 0; opts.currSlide = firstSlideIndex; if ( opts.reverse ) { opts.nextSlide = firstSlideIndex - 1; if (opts.nextSlide < 0) opts.nextSlide = opts.slides.length - 1; } else { opts.nextSlide = firstSlideIndex + 1; if (opts.nextSlide == opts.slides.length) opts.nextSlide = 0; } }, calcNextSlide: function() { var opts = this.opts(); var roll; if ( opts.reverse ) { roll = (opts.nextSlide - 1) < 0; opts.nextSlide = roll ? opts.slideCount - 1 : opts.nextSlide-1; opts.currSlide = roll ? 0 : opts.nextSlide+1; } else { roll = (opts.nextSlide + 1) == opts.slides.length; opts.nextSlide = roll ? 0 : opts.nextSlide+1; opts.currSlide = roll ? opts.slides.length-1 : opts.nextSlide-1; } }, calcTx: function( slideOpts, manual ) { var opts = slideOpts; var tx; if ( opts._tempFx ) tx = $.fn.cycle.transitions[opts._tempFx]; else if ( manual && opts.manualFx ) tx = $.fn.cycle.transitions[opts.manualFx]; if ( !tx ) tx = $.fn.cycle.transitions[opts.fx]; opts._tempFx = null; this.opts()._tempFx = null; if (!tx) { tx = $.fn.cycle.transitions.fade; opts.API.log('Transition "' + opts.fx + '" not found. Using fade.'); } return tx; }, prepareTx: function( manual, fwd ) { var opts = this.opts(); var after, curr, next, slideOpts, tx; if ( opts.slideCount < 2 ) { opts.timeoutId = 0; return; } if ( manual && ( !opts.busy || opts.manualTrump ) ) { opts.API.stopTransition(); opts.busy = false; clearTimeout(opts.timeoutId); opts.timeoutId = 0; } if ( opts.busy ) return; if ( opts.timeoutId === 0 && !manual ) return; curr = opts.slides[opts.currSlide]; next = opts.slides[opts.nextSlide]; slideOpts = opts.API.getSlideOpts( opts.nextSlide ); tx = opts.API.calcTx( slideOpts, manual ); opts._tx = tx; if ( manual && slideOpts.manualSpeed !== undefined ) slideOpts.speed = slideOpts.manualSpeed; // if ( opts.nextSlide === opts.currSlide ) // opts.API.calcNextSlide(); // ensure that: // 1. advancing to a different slide // 2. this is either a manual event (prev/next, pager, cmd) or // a timer event and slideshow is not paused if ( opts.nextSlide != opts.currSlide && (manual || (!opts.paused && !opts.hoverPaused && opts.timeout) )) { 